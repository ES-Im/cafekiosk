## @Transactional

---
### @Transactional의 역할 - 1.변경 감지(Dirty Checking)
* 더티 체킹이 동작하는 조건
    - 엔티티가 `영속 상태`일 것 ( ==  Detached(준영속) 상태에서는 안 된다)
    - `transaction` 안에서 변경될 것
* 더티 체킹 내부 흐름
    - 엔티티 조회 : JPA가 최초 상태 스냅샷을 저장(JPA는 엔티티를 조회하면 1차 캐시에 저장하고 최초 상태 스냅샷을 같이 보관)
    - 자바 코드 값 변경 (아직 DB변경 x)
    - 트랜잭션 커밋 시점 : 스냅샷과 현재 값 비교
    - 값이 다르면 `UPDATE` SQL 쿼리 생성 및 실행<br>
      → 즉, save()쿼리를 실행하지 않아도 JPA 프레임 워크가 변경 책임을 대신 져주는 것

* 즉, 더티체킹을 활용하지 않으려면 비즈니스로직에서 save를 통해 update를 해줘야 한다.
```aiignore
public OrderResponse createOrder(OrderCreateRequest request, LocalDateTime registeredDateTime) {
    // ...(생략)...
    Order savedOrder = orderRepository.save(order);
    return OrderResponse.of(savedOrder);
}
```
---
### @Transaction의 역할 - 2. 자동롤백
* 테스트 메서드에 @Transactional 사용 시 테스트 종료 후 자동 롤백 DB 상태가 깨끗하게 유지됨
* 즉, 매번 데이터 삭제 코드 작성이 불필요해서 테스트 코드가 단순해진다.
---
### 테스트 트랜잭션 주의점
* 테스트에서 @Transactional 덕분에 더티 체크가 정상 동작하고 UPDATE 쿼리도 정상확인이 된다
* 하지만 실제 서비스 코드에서 트랜잭션이 설정되지 않으면 배포 후에야 문제 발견 가능
* 그러므로 테스트에서는 자동 롤백 방식 대신 수동 삭제(tearDown) 방식을 유지하는 것도 해결방안이며, 이는
    * 트랜잭션에 의존치 않은 테스트를 작성하여 숨겨진 문제를 조기에 발견할 수 있다.
```aiignore
@AfterEach
void tearDown() {
    orderProductRepository.deleteAllInBatch();
    productRepository.deleteAllInBatch();
    orderRepository.deleteAllInBatch();
    stockRepository.deleteAllInBatch();
}
```
---
### @Transactional(readOnly = true)
#### 기본 개념
    - @Transactional(readOnly = true)는 읽기 전용 트랜잭션(Read Transaction) 임을 명시적으로 선언하는 옵션이다.
    - ❌ CUD(Create / Update / Delete) 불가
    - ✅ Read 전용 트랜잭션 : 트랜잭션 범위는 유지되지만 변경을 허용하지 않음

#### JPA 관점에서의 동작 방식 (성능 포인트)
    - readOnly = true가 설정되면 JPA(Hibernate)는 내부 동작을 최적화한다.
    - ❌ 스냅샷(Snapshot) 저장 안 함
    - ❌ Dirty Checking(변경 감지) 비활성화
    - ❌ flush 시점의 UPDATE SQL 생성 안 함
    - ✅ 메모리 사용량 감소
    - ✅ 조회 성능 향상

#### CQRS 관점에서의 의미
    - CQRS(Command Query Responsibility Segregation)는 쓰기(Command)와 읽기(Query)의 책임을 분리하는 아키텍처 패턴이다.
    - 핵심 이유
        1. 대부분의 시스템 부하는 Read에서 발생
        2. Read 부하 때문에 Write(Command)가 지연되면 안 됨
        3. 따라서: Read는 Read에 최적화 Write는 Write에 집중
#### 서비스 레벨 분리 전략
    ① 쿼리(Query) 서비스와 커맨드(Command) 서비스 분리 

    ② 클래스에 readOnly=true를 걸고
    👉 CUD 메서드에만 명시적으로 @Transactional을 선언하면
    👉 CUD 누락 사고를 방지할 수 있다.
         ↓
        @Transactional(readOnly = true)
        @Service
        public class ProductService {
        
            public ProductResponse getProduct(Long id) {
                // 조회 로직
            }
        
            @Transactional // readOnly = false
            public ProductResponse createProduct(ProductCreateRequest request) {
                // 생성 로직
            }
        }

#### DB 엔드포인트 분리 전략
    Aurora / MySQL Replication 구조에서는 보통:
     - Master DB :Write(CUD) 전용
     - Replica(Slave) DB : Read 전용
    이때 readOnly 값으로 DB 라우팅 분리가 가능하다.
#### DB 엔드포인트 분리 방법
    ① Amazon Aurora Cluster Mode
        하나의 엔드포인트 사용
        Aurora가 readOnly 여부를 보고 자동 라우팅
    ② Spring에서 명시적 분리
        DataSource를 Read / Write로 분리
        라우팅 DataSource 사용

---
### @Transactional이 없는데도 insert와 delete 쿼리가 자동 실행되는 이유?
* CRUDRepository 의 구현체를 보면 `save`에 @Transactional이 설정이 되어있다<br> 그래서 `insert` 쿼리와 delete 쿼리는 자동 감지가 된다.

---
### 트랜잭션을 굳이 걸 필요가 없는 부분
#### 1. 트랜잭션 = DB커넥션을 오래 잡는 행위
  * 트랜잭션 범위가 길어질수록 커넥션 풀 점유 시간이 증가하여 동시 요청이 많을 때 병목 현상 가능성이 증가
#### 2. 조회만 해도 커넥션은 필요하다
  * 따라서 조회 중심 로직에서는 서비스 레벨에 `@Transactional`을 명시적으로 걸지 않아도 된다.
  * 엄밀히 말하면:
    - 서비스 레벨에서 `@Transactional`을 안 달아도 된다
    - 리포지토리 레벨에서는 짧은 트랜잭션이 내부적으로 사용됨
#### 3. 트랜잭션 + 트랜잭션과 무관한 작업 시 문제가 된다
  * 메일 전송, 외부 API 호출, 긴 네트워크 작업 같은 것들은
    * 시간이 오래걸리고
    * DB 일관성과 직접적 관련이 없음
    * 트랜잭션 안에 넣으면 DB 커넥션을 쓸데없이 계속 잡고있는다.
  * 특히 조회 로직에서는 DB 조회 이후 메일 전송이나 외부 네트워크 호출처럼 트랜잭션과 직접적인 관련이 없는 작업이 포함되는 경우가 많다. 
    <br>이런 작업까지 트랜잭션 안에 포함시키면, 실제로는 DB 작업이 끝났음에도 불구하고 커넥션을 계속 점유하게 된다.
### 그러므로 "조회 중심 서비스"에는 트랜잭션을 안 거는게 낮다 
  * 조회 중심의 서비스에서는 서비스 레벨에서 트랜잭션을 명시적으로 걸지 않는 것이 바람직하다.
  * 트랜잭션은 데이터 변경이 필요한 최소 범위에만 적용하는 것이 좋고, <br>
    조회 위주의 서비스에서는 오히려 트랜잭션을 생략하는 것이 성능과 자원 관리 측면에서 더 적절하다.
#### 그럼 `@Transactional(readOnly = true)`를 클래스 단위로 묶으면 헷갈리지 않나? 
  * ㄴㄴ 아님. 애초에 조회전용서비스와 외부 연동 서비스를 분리해야된다. 
  * 예시 ↓
```    
@Transactional(readOnly = true)
public Order getOrder(Long orderId) {
return orderRepository.findById(orderId);
}

public ExternalResult callExternal() {
return externalApi.call();
}
```

## 트랜잭션의 "사이드 이펙트"를 고려해라 라는 의미
> 테스트 환경에서 만들어진 ‘안전함’이 실제 프로덕션 코드의 위험을 가려버릴 수 있다

1. 테스트에는 @Transactional, 프로덕트 코드에는 없는 경우
   - 내가 의도하지 않은 책임까지 묶여버림 (외부 API등)
   - DB변경의 원자성이 깨져버림 : 테스트 코드에서는 여러 DB 변경이 하나의 작업으로 묶이지만, 프로덕션에서는 앞의 DB는 commit 뒤에서 예외 발생 시 중간이 비어버린다
2. 더티 체킹이 테스트에서는 “묻고”, 프로덕트에서는 “안 묻는” 경우
    - 프로덕트 코드에서의 예기치 못한 오류를 발견하지 못함
    - 예를들어 transactional (readOnly) 상황에서도 테스트 코드에서 스냅샷 비교에 의한 업데이트가 될 수 있음

### 즉, ‘항상 깨끗하고 각 테스트 간 독립적인 DB’는 오히려 실제 오류를 배포 후까지 숨길 수 있다.