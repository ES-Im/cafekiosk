# 한 문단에 한 주제

---
* 대상 테스트 : `ProductTypeTest`

## 테스트는 “검증”이 아니라 “의도를 설명하는 문서”다.

---
* 단위 테스트에서는 테스트 코드의 구조와 의도를 가장 중요하게 봐야 한다.
* 테스트 코드는 글쓰기와 유사하며,<br>
  한 문단에는 하나의 주제만 있어야 하듯, 하나의 테스트 메서드도 하나의 검증 목적만 가져야 한다.
* 주제가 여러 개이면 읽는 사람이 헷갈리는 것처럼,<br>
  하나의 테스트에 여러 검증 목적이 섞이면 테스트의 의도가 흐려진다.
* 테스트 코드에는 분기문이나 반복문이 없어야 한다.
* 테스트 메서드 이름만 보아도 무엇을 검증하는지 명확하게 드러나야 한다.
* 또한 테스트는 실패했을 때 원인을 즉시 파악할 수 있도록 작성되어야 한다.
## `ProductTypeTest` 클래스 리팩토링 전 테스트코드 문제

---
### 테스트에 논리가 있으면 안된다.
* 반복문과 조건문이 포함되어 있어, 테스트를 이해하기 위해 추가적인 사고와 흐름 추적이 필요하며 직관적이지 않다.
* 분기문이나 반복문이 있다는 사실 자체가 이미 테스트가 여러 케이스를 동시에 다루고 있다는 신호이다.
### 테스트에서 중요한 건 '의도 전달력'이다.
* true와 false를 반환하는 서로 다른 검증 주제를 하나의 테스트 메서드에 함께 포함시켜, 테스트의 의도가 명확하지 않다.
### 테스트가 실패하면 어느 케이스가 실패했는지 바로 알 수 있어야 한다.
* HANDMADE? BAKERY? BOTTLE? true? false? 어느 쪽이 실패한 건지 테스트 이름만으로 알아볼 수 없으면 그 테스트는 설계가 잘못 된 것이다.

## 정리하면

---
* 테스트는 모든 케이스를 한 번에 검증하려는 도구가 아니라, 의미 있는 하나의 행위를 명확히 보장하기 위한 문서다.

### ※ Parameterized Test

---
#### 사용하는 이유 
* "테스트 하나 = 하나의 주제"의 틀을 유지하면서 중복만 제거하고 싶을 때 parameterized Test를 고려할 수 있다.
#### 사용할 수 있는 상황
* 검증 목적이 하나일 때
  * 재고 관련 상품이면 true, 재고 관련 상품이 아니면 false<br>
  → 목적은 변하지 않고, 입력값만 달라지는 경우이다.
* 분기 / 반복이 테스트 코드에 생기려 할 때
* 같은 assert가 반복될 때
* 즉, `ProductTypeTest`의 리팩토링 전 메서드와 같은 상황임.



# 완벽하게 제어하기

---

* 테스트를 위해서는 테스트 환경에 영향을 주는 모든 조건을 우리가 완벽하게 제어할 수 있어야 한다.
* 테스트는 “잘 되길 기대하는 코드”가 아니라 항상 동일한 결과를 보장하는 코드여야 한다.
* 이를 위해: 현재 시간, 랜덤 값, 외부 시스템 같은 통제 불가능한 요소를 제거하거나 분리해야 한다.
  * 즉, 위 요소들을 반드시 상위 계층으로 분리해서 주입해야한다.

## LocalDateTime.now()
* 해당 코드는 문제가 "지금은" 괜찮아 보이는 코드이지만, 
* 문제점
  * 제어할 수 없고, 
  * 테스트 실행 환경에 따라 달라질 수 있으며
  * 시간이 흐르면 `now()` 코드가 번진다.
* 해결
  * `LocalDateTime fixedTime = LocalDateTime.of(2024, 1, 1, 10, 0);`
  * 테스트가 시간을 결정토록하여 테스트 환경을 완전히 통제해야한다.


    
# 테스트 환경의 독립성을 보장하자

---

## 테스트 실패와 관련된 문제 부분 
* 대상 테스트 :  `OrderServiceTest.createOrderWithNoStock`
* given / when / then 중 잘못된 설계의 문제는 거의 항상 given에서 발생
* 문제의 원인 : 테스트 간 결합, 즉 아래부분을 무심코 끌어다 쓰는 경우 테스트 간 결합 가능성이 생긴다.
  * 다른 테스트에서 사용한 API
  * 다른 도메인의 행위
  * 상태 변경 메서드
* 문제 예시 
  * `@DisplayName("재고가 부족한 상품으로 주문을 생성하려는 경우 예외가 발생한다.")`
  * 즉 위 테스트 주제는 "재고가 부족하면 주문 생성이 실패" 하는데에 있다.
  * 하지만 given절에서 직접적으로 재고 차감 로직을 호출 
    * `stock1.deductQuantity(1);` 👉 문제의 핵심 포인트
    * 해당 테스트는 재고 차감(`deductQuantity`) 로직을 테스트 하려는게 아닌 주문 생성 로직(`createOrder`)에 있다 <br>
      👉 주제와 맞지 않는 행위를 given에 끌어옴
  * 위 문제가 안좋은 이유는 : 테스트 환경이 행위에 의존함<br>
    재고를 “만들기 위해” 재고 차감이라는 행위 API를 사용 👉 이건 테스트 환경 구성에: 비즈니스 로직이 끼어든 상태

## 테스트의 기본 원칙
  * 테스트 환경을 독립성을 보장하여 "왜"실패했는지를 명확하게 만들어야 한다.
  * 각 테스트는 서로에게 영향을 주지 않아야 하며, 실패했을 때 그 원인이 오직 “해당 테스트의 목적” 때문이어야 한다.
  * 테스트 환경은 행위로 만들지 말고, 상태로 만들어라.
  * 즉, deduct / create와 같은 행위메서드를 사용하는 것 보단
  * 생성자 / 빌더 / 순수 팩토리 메서드를 사용하는 것이 더 테스트 의도를 드러내는데 좋다. <br>
    ※ 프로덕션 코드에서 팩토리 메서드는 의도를 담고있다. 그러므로 테스트 코드에서는 순수 생성자 / 빌더가 더 적합한 경우가 많음



# 테스트 간 독립성을 보장하자

---
## 테스트 실패와 관련된 문제 부분
* 대상 테스트 : `StockTest`의 주석 부분의 `final stock` 변수
  * 여러 테스트가 하나의 공유 자원을 사용함 👉 테스트 실행 순서에 따라 결과가 바뀌는 구조
  
## 테스트의 기본 원칙 👉 테스트 간 독립성 보장
* 각 테스트는 서로 영향을 주면 안 된다
* 실행 순서에 따라 성공/실패가 달라지면 안 된다
* 어떤 테스트든 단독 실행 / 전체 실행 모두 동일한 결과를 내야 한다

## 만약 테스트 간 순서를 제어하고 싶다면?
* Dynamic Test
* Parameterized Test

# Test Fixture 구성하기

---
## Test Fixture
* 텍스트 픽스쳐 = 테스트 목적, 환경을 위해 미리 고정해 둔 객체 
* 테스트 목적을 수행하기 위해 `given`절에서 생성한 모든 객체와 상태 값의 집합

## JUnit 생명주기 메서드 개념
* `@BeforeAll` 
  * 테스트 클래스 전체 실행 전 딱 한 번 
  * 공통 설정이나 리소스 준비에 사용 가능 > 공유 자원으로 사용 시 테스트 결합 위험 존재
* `@BeforeEach` 
  * 각 테스트 메서드 실행 직전마다
  * 테스트마다 초기 상태 보장
* `@AfterEach` (tearDown)
  * 각 테스트가 끝난 직후
  * deleteAllInBatch > DB 클린업 용도
* `@AfterAll`
  * 테스트 전체 종류 후 한번

## 1️⃣ JUnit 메서드 픽스처가 항상 좋은게 아니다.
1. 파편화로 인한 가독성 하락
   * 중복 제거를 위한 기본 픽스처 생성을 위해 Before이나 After을 사용할 순 있지만
   * 독자 입장에서는 테스트 문단을 읽는데 given을 이해하기 위해 다른 문단(setup)을 왔다갔다 해야한다
   * 즉, 글이 파편화 되어있어서 파악하기 어려움
2. 픽스처 수정 시 테스트 전체에 영향 가능
   * 이는 즉, 테스트 독립성을 훼손한다.
   
### 그래서 언제 @BeforeEach / @BeforeAll을 써야 할까?
  1. setup 내용을 몰라도 테스트 메서드만 보고 이해 가능한가? <br>
    → 대안: createXXX() 같은 헬퍼 메서드로 추출
  2. setup이 수정돼도 다른 테스트가 깨지지 않는가?
>  * 👉 하나라도 NO라면 <br>
    중복이 있더라도 테스트 메서드 내부에 두는 게 낫다

## 2️⃣ 기본 데이터(data.sql)를 테스트 픽스처로 사용하는 방식은 추천하지 않는다
1. 테스트 문서성이 급격히 떨어진다 : given 절이 외부 파일로 빠져서 문서 파편화
2. 테스트 픽스처가 코드가 아닌 SQL로 숨는다 
3. 유지보수 비용이 기하급수적으로 증가 : 테스트파일 뿐만 아니라 data.sql도 이중 관리를 하게 된다.
4. 테스트 간 결합도가 생긴다 : 엔티티 자체가 변경되면 테스트를 위해 데이터를 수정해야한다 → 테스트 간 독립성 붕괴

> 즉, data.sql는 로컬 개발 환경 초기 데이터로만 쓰고 테스트용도로는 사용을 피하자.

## 3️⃣ 테스트 픽스처 생성 시, 테스트 목적에 맞게 “필요한 것만” 드러내라
* 기본 데이터 픽스처를 테스트 클래스 내에서 builder를 이용해 생성할 때, 파라미터로 빼는건 각 테스트별로 "필요한 필드"만 받는 create 메서드로 만들자 
* 빌더 패턴 내에서 테스트에서 공통으로 중요하지 않는 인자값은 과감히 고정해둔다. (고정함으로서 독자가 해당 값에 대해 생각하지 않도록 한다.)
* 해당 픽스처는 테스트 클래스마다 달라도 문제 없다. 독자가 이해할수 있고 각 테스트간 독립성만 지키면 된다.

> 즉, 프로덕션용 빌더에서 필요한 파라미터만 테스트에 노출시키고, 중요하지 않는건 고정값으로 박아두자. 

## 4️⃣ 그럼 테스트 픽스처를 한 곳에 몰아넣는건? 
> 결론부터 이야기하면 ❌ 가능은 하지만 추천하지 않는다, <br>
> 중복이 생기더라도 테스트마다 픽스처는 달라도 되며, 공통으로 몰아두지 않는 것이 낫다.

### 비추천 이유 
* 테스트 전용 공통 Fixture Builder를 한 곳에 모으면 향 후 협업단계에서 필드가 수십 개까지 늘어남
* 테스트마다 필요한 필드가 다르므로 하나의 공통 빌더에 모든 필드가 파라미터로 노충
* 결국엔 어떤 필드가 중요한지도 모르겠고, 파라미터 순서/의미를 계속 확인하는 사고 비용증가
* 문서 파편화로 "문서"로 보기 어려워짐


# Test Fixture 클렌징
> Transactional과 DeleteAllInBatch, DeleteAll의 차이와 클렌징 전략
> - transactional과 deleteAllInBatch를 혼용해서 사용
___
## Fixture 클렌징이 필요한 이유?
* 테스트는 "항상 같은 결과"를 내야 한다.
  * 이전 테스트의 데이터가 남아 있으면 테스트 간 결합 & 실행 순서에 따라 성공/실패가 달라지는 flakey test 발생
* 예시
  * [ Order - OrderProduct - Product ] 관계에서 Product, Order만 삭제하면 OrderProduct가 DB에 고아 데이터로 남음
  * 다음 테스트에서 예상치 못한 영향 발생

## 방법

1. deleteAllInBatch() : `DELETE FROM table` 형태로 조건 없이 한 번에 실행
   * 특징 : JPA 영속성 컨텍스트를 무시 (cascade / orphanRemoval 동작 x) 
   * 장점 : 빠름 
   * 단점 : FK, 고아데이터, 순서를 모두 고려하여 설정해야함
2. deleteAll() : `SELECT * FROM table` 후 `Delete FROM TABLE WHERE id = ?` 반복
   * 특징 :  영속성 컨텍스트를 거쳐 cascade, orphanRemoval 정상 동작
   * 장점 : 안정적
   * 단점 : 테스트 비용이 급격히 증가 하고, FK를 고려하여 순서맞춰야 동작
3. @transactional (롤백 기반 테스트 격리)
    * 테스트 종료 시 롤백을 통해 데이터 정합성 보장
    * 단, **사이드 이펙트**를 알고 사용할 것
    * 장점 : 단순하고 안전한 방식
    * 단점 : 트랜잭션 경계가 여러 개의 테스트 (배치, 통합 테스트)에서는 실제 commit 상황을 고려하여 테스트 하기 어려움
    * 주의 : 사이드 이펙트를 반드시 고려하고 사용해야함

>DeleteAll()을 추천하지 않는 이유? <br>
> 1. findAll() 한 후 반복문으로 하나씩 delete() 하므로 쿼리가 많아짐 
> 2. 테스트도 비용이기 때문에 다수의 쿼리 때문에 작업량에 있어서 시간적으로 비용이 든다. 
> 3. 관계 및 순서만 잘 파악한다면 deleteAllInBatch()도 배치성 삭제로 적절하다
> 4. 또는 사이드 이펙트를 잘 파악한다면 transactional을 사용해도 된다.

# [ParameterizedTest](https://docs.junit.org/6.0.2/writing-tests/parameterized-classes-and-tests.html#setup)
> 대상 테스트 및 코드 : ProductTypeTest
---

## 언제 사용하나?

* 테스트 코드에 반복문 / 분기문은 지양
  * 반복·분기는 테스트 안에 여러 주제를 담게 됨
  * 실패 시 어떤 케이스가 문제인지 즉시 파악하기 어려움

* 하지만,
  * 검증 로직은 하나
  * 입력 값만 바꿔가며 동일한 검증을 반복하고 싶을 때가 있음 👉 이럴 때 **@ParameterizedTest**를 사용한다.

> 즉, **“하나의 테스트 주제 + 여러 입력 케이스”**인 경우에 적합

## 주요 Source 종류
1. `@CsvSource` 👍 : 여러 파라미터를 한 번에 전달 <br> 
   - `ProductTypeTest.containsStockType1` 메서드 참고
2. ` @MethodSource` 👍 : 복잡한 객체, 조건 조합이 필요한 경우  <br> 
   - `ProductTypeTest.containsStockType2` 메서드 참고 <br>
   - tip : 이를 이용하면 given절을 테스트 메서드에서 분리한 것과 같다, 가독성을 위해서 대상 테스트 메서드 바로 위에 위치시키는게 좋음
3. @ValueSource : 단일 파라미터만 전달 가능, 가장 단순한 케이스에 적합<br>
   - `@ValueSource(strings = {"A", "B"})`
4. @NullSource/@EmptySource : null / empty 값 테스트 전용

## DisplayName 인덱스 커스터마이징
- `ProductTypeTest.containsStockType1` 메서드 참고
```
커스텀된 테스트 실행 결과
> 상품 타입이 재고 관련 타입인지를 체크한다                   - DisplayName
   > 1 ==> Type: 'HANDMADE' 일때 재고타입은 false이다        - ParameterizedTest 인덱스 커스텀 결과
   > 2 ==> Type: 'BOTTLE' 일때 재고타입은 true이다
   > 3 ==> Type: 'BAKERY' 일때 재고타입은 true이다
```
- `@ParameterizedTest(name = "{index} ==> custom {0} {1} {2} .....")` 형식에 맞추어 테스트하면 됨
- index는 Test 메서드의 매개값과 매칭
- 소단원 인덱스 설정 시 각각의 테스트 결과를 확인할 수 있다.



# @DynamicTest
> 대상 테스트 및 코드 : `StockTest.dynamicTests`
---
### 기존 테스트 
* 기존 테스트에서 '공유 자원'을 사용하면 테스트 간 독립성이 깨짐
* '공유자원'을 피하려면 `given - then - given - then `반복 → 가독성 저하 및 중복코드 발생

### DynamicTest를 사용하는 이유 
* 『하나의 공통 환경에서 - 상태가 단계적으로 변화하는 - 사용자 시나리오 기반 검증』 을 하고 싶은 경우

### DynamicTest 정의와 기본 구조 
#### 정의와 목적
* 테스트 실행 시점(runtime)에 테스트 케이스를 동적으로 생성하는 방식
* 테스트를 “절차적 스크립트”가 아니라 시나리오 문서처럼 작성
#### 기본 구조
* 정적인 @Test 메서드 선언과 다름
* ParameterizedTest의 Display_name 인덱스 커스텀과 유사하게 소단원별 테스트 결과를 확인할 수 있다.
```
@TestFactory
Collection<DynamicTest> dynamicTests() {
// given: 공통 환경 설정

    return List.of(
        DynamicTest.dynamicTest("시나리오 1", () -> {
            // when // then
        }),
        DynamicTest.dynamicTest("시나리오 2", () -> {
            // when // then
        })
    );
}
```

# 테스트 환경 통합
> 테스트 수행하는 것도 비용이기 때문에 관리가 필요하다. <br>
> 대상 환경 통합 추상 클래스 : `ControllerTestSupport`, `IntegrationTestSupport`
---
## 테스트 환경 통합을 해야하는 이유 
* 전체 테스트 시, 서버가 자주 띄어지면 테스트 시간이 길어짐
> * 전체테스트 타이밍
>   * 커밋 직전
>   * 피처 브랜치 기능을 다 만든 뒤 origin repo로 push하기 직전
> * 서버 재구동 횟수 확인 방법 : gradle > verification > test 후 'spring boot' 검색
* 테스트 수행 시간 자체가 비용이라서 이도 관리가 필요하다.

## 테스트 시간 줄이기 - 서버 재구동 횟수 줄이기
### 원인
* 각 테스트 클래스 간 환경구성 차이, Mock 사용 여부 등 config annotation들이 조금이라도 다르면 톰캣 서버를 새로 구동한다. 
> 구성정보 : `@SpringBootTest` `@DataJpaTest` `@ActiveProfiles("test")` `@MockMvc` `@WebMvcTest` 등


### 해결방법
#### 동일한 환경에서 수행되도록 공통 환경을 모아주면 서버 뜨는 시간을 줄일 수 있다.
> 예시
> - ControllerTestSupport : WebMvc 및 mocking 처리를 공통으로 묶어둔 "컨트롤러 테스트" 공통 구성정보 추상 클래스
>> [부모 클래스]
>> ```
>> @WebMvcTest(controllers = {
>>     OrderController.class,
>>     ProductController.class
>> })
>> public abstract class ControllerTestSupport {
>> @Autowired protected MockMvc mockMvc;
>> 
>>     @Autowired protected ObjectMapper objectMapper;
>> 
>>     @MockitoBean protected OrderService orderService;
>> 
>>     @MockitoBean protected ProductService productService;
>> }
>> ```
>>  [자식 클래스 - 구성정보 없음]
>>  ```
>>  class OrderControllerTest extends ControllerTestSupport {}
>>  ```
>>
> - IntegrationTestSupport : springBootTest 및 profile 구성을 공통으로 묶어둔 "서비스 & 레파지토리" 공통 구성정보 추상 클래스
>> [부모 클래스]
>>  ```
>>  @ActiveProfiles("test")
>>  @SpringBootTest
>>  public abstract class IntegrationTestSupport {}
>> ```
>>  
>>  [자식 클래스 - 구성정보 없음]
>>  ```
>>  class OrderServiceTest extends IntegrationTestSupport {}
>>  ```

### Service에서 Mocking 처리 된 것도 서버 재구동 원인이다
> 대상테스트 : `OrderStatisticsServiceTest` → 프로덕션 객체를 MockBean처리를 했기 때문에 서버가 새로 구동됨
* 선택지 1) MockBean을 공통 구성정보(부모)로 올리기
  * `@MockBean producted(← private 수정) MailSendClient mailSendClient;`를 부모 클래스(IntegrationTestSupport)로 옳기기
  * 이 방식은 결과적으로 먹빈이 다른 서비스 테스트에도 먹빈으로 들어감
* 선택지 2) 테스트 환경을 두 개로 나누기
  * 먹빈 전용 구성정보 클래스를 따로 만들고 먹빈이 필요한 애들은 그 환경으로, 먹빈이 전혀 필요 없는 테스트는 먹빈 환경을 안 타게 한다
  * 즉 서버 2개를 띄우는 대신 “필요 없는 테스트까지 먹빈 처리하지 않게” 만든다

### Repository 테스트는 서비스와 “통합 가능” (옵션사항)
> 대상 테스트 : `StockRepositoryTest`, `ProductRepositoryTest`
#### 옵션사항 : Repository Test에서 `@SpringBootTest`을 쓸건가? `@DataJpaTest`을 쓸건가? 
* `@DataJpaTest`는 repository bean만 띄우지만, 전체 테스트 관점에서는 `@SpringBootTest`와 구성정보가 달라서 어차피 서버를 새로 띄운다.
* 그래서 이미` @SpringBootTest` 환경이 떠있다면 repository 테스트도 `@SpringBootTest`로 묶어서 “같은 서버 이용”이 가능하다.
* `DataJpaDate` 만을 사용해야하는 목적이 꼭 있는게 아니라면, `@SpringBootTest` 구성정보를 이용하는게 더 간편할 수 있다.

#### 주의점
* DataJpaTest는 트랜잭션 annotation이 구성되어 있는데 SpringBootTest에서는 제외되어 있다
* 그래서 @Transactional을 붙이거나, fixture cleansing를 tearDown으로 하거나 선택해야 한다.

### Controller 테스트는 서비스 테스트와 통합이 “어렵다”
* 컨트롤러는 컨트롤러만 띄우고 서비스는 모킹해서 빠르게 검증하는 성격이라, 통합 테스트랑 환경 구성이 다름
* 그래서 WebMvc 테스트를 위한 환경을 별도로 구축 
* mock, objectMapper, mockitoBean 주입도 해당 추상클래스에 밀어넣으면 컨트롤러 테스트를 위한 서버도 한번만 띄울수있다

## 정리
- 전체 테스트 비용을 줄이려면 서로 다른 구성정보(프로파일/먹빈/어노테이션 차이) 때문에 스프링 서버가 여러 번 뜨는 걸 줄이고, 
- 이를 위해 공통 설정을 Support 추상 클래스로 묶되, 
- MockBean이 필요한 테스트는 (1) 공통으로 올리거나 (2) 환경을 두 개로 나누는 선택을 한다.
- Repository는 서비스 환경과 묶을 수 있고(구성정보만 같다면), 
- Controller는 WebMvc 전용 Support로 따로 묶어서 서버를 최소 단위로 줄인다. 

# private 메서드의 테스트

> private 메서드 테스트를 할 필요 없고, 해서도 안된다. <br>
> 대상 테스트 : ProductService
---
#### private 메서드를 테스트 하고싶다 라고 생각을 드는 순간, 객체를 분리할 시점인가 고민해야한다.

* 객체가 공개한 API들을 테스트하다 보면 자연스럽게 private 부분도 자연스럽게 검증이 되기 때문에 할 필요가 없다
* 만약에 private method를 테스트하고 싶다면 객체 분리의 신호로 봐야한다. 
* 만약 하나의 공개 API(public method) 안에서 하는 일이 너무 많나? 이 객체가 가지는 일이 이게 다 맞을까에 대한 의문이 던져진다면
* private method라는 이 하나의 작은 기능을 별도의 객체로 빼서 의존성 주입을 시키고 각각 테스트를 하면 된다.

#### 예시 
* `ProductService`에서 private인 `createNextProductNumber()` 라는 메서드는 `createProduct()`을 테스트 하면서 자연스럽게 테스트가 같이 된다.
* 그런데 만약, `createProduct()`의 기능이 너무 많아서 "내부 기능을 각각 테스트 하고 싶다" 생각이 든다면
* `createNextProductNumber()`를 따로 createProductFactory 객체로 빼내어 별도로 테스트를 하면 된다. 

# 테스트에서만 필요한 메서드가 있다면 어떻게 해야하나?

> 만들어도 된다. 하지만 보수적으로 접근해야한다. <br>
> 대상 테스트 : ProductCreateRequest

---
* 대상 DTO객체에서 ProductCreateRequest의 빌더패턴은 테스트에서만 사용이 되고 프로덕션 코드에서는 사용되지 않는다. 
* 프로덕션 코드 명세에 맞는 기능과 관련된 메서드이자 미래에도 충분히 사용도리 수 있는 성격의 메서드라면 프로덕션 코드에 남겨놔도 된다.
* 하지만 이가 아니라면 지양하는 것이 맞다.
