# 한 문단에 한 주제

---
* 대상 테스트 : `ProductTypeTest`

## 테스트는 “검증”이 아니라 “의도를 설명하는 문서”다.

---
* 단위 테스트에서는 테스트 코드의 구조와 의도를 가장 중요하게 봐야 한다.
* 테스트 코드는 글쓰기와 유사하며,<br>
  한 문단에는 하나의 주제만 있어야 하듯, 하나의 테스트 메서드도 하나의 검증 목적만 가져야 한다.
* 주제가 여러 개이면 읽는 사람이 헷갈리는 것처럼,<br>
  하나의 테스트에 여러 검증 목적이 섞이면 테스트의 의도가 흐려진다.
* 테스트 코드에는 분기문이나 반복문이 없어야 한다.
* 테스트 메서드 이름만 보아도 무엇을 검증하는지 명확하게 드러나야 한다.
* 또한 테스트는 실패했을 때 원인을 즉시 파악할 수 있도록 작성되어야 한다.
## `ProductTypeTest` 클래스 리팩토링 전 테스트코드 문제

---
### 테스트에 논리가 있으면 안된다.
* 반복문과 조건문이 포함되어 있어, 테스트를 이해하기 위해 추가적인 사고와 흐름 추적이 필요하며 직관적이지 않다.
* 분기문이나 반복문이 있다는 사실 자체가 이미 테스트가 여러 케이스를 동시에 다루고 있다는 신호이다.
### 테스트에서 중요한 건 '의도 전달력'이다.
* true와 false를 반환하는 서로 다른 검증 주제를 하나의 테스트 메서드에 함께 포함시켜, 테스트의 의도가 명확하지 않다.
### 테스트가 실패하면 어느 케이스가 실패했는지 바로 알 수 있어야 한다.
* HANDMADE? BAKERY? BOTTLE? true? false? 어느 쪽이 실패한 건지 테스트 이름만으로 알아볼 수 없으면 그 테스트는 설계가 잘못 된 것이다.

## 정리하면

---
* 테스트는 모든 케이스를 한 번에 검증하려는 도구가 아니라, 의미 있는 하나의 행위를 명확히 보장하기 위한 문서다.

### ※ Parameterized Test

---
#### 사용하는 이유 
* "테스트 하나 = 하나의 주제"의 틀을 유지하면서 중복만 제거하고 싶을 때 parameterized Test를 고려할 수 있다.
#### 사용할 수 있는 상황
* 검증 목적이 하나일 때
  * 재고 관련 상품이면 true, 재고 관련 상품이 아니면 false<br>
  → 목적은 변하지 않고, 입력값만 달라지는 경우이다.
* 분기 / 반복이 테스트 코드에 생기려 할 때
* 같은 assert가 반복될 때
* 즉, `ProductTypeTest`의 리팩토링 전 메서드와 같은 상황임.



# 완벽하게 제어하기

---

* 테스트를 위해서는 테스트 환경에 영향을 주는 모든 조건을 우리가 완벽하게 제어할 수 있어야 한다.
* 테스트는 “잘 되길 기대하는 코드”가 아니라 항상 동일한 결과를 보장하는 코드여야 한다.
* 이를 위해: 현재 시간, 랜덤 값, 외부 시스템 같은 통제 불가능한 요소를 제거하거나 분리해야 한다.
  * 즉, 위 요소들을 반드시 상위 계층으로 분리해서 주입해야한다.

## LocalDateTime.now()
* 해당 코드는 문제가 "지금은" 괜찮아 보이는 코드이지만, 
* 문제점
  * 제어할 수 없고, 
  * 테스트 실행 환경에 따라 달라질 수 있으며
  * 시간이 흐르면 `now()` 코드가 번진다.
* 해결
  * `LocalDateTime fixedTime = LocalDateTime.of(2024, 1, 1, 10, 0);`
  * 테스트가 시간을 결정토록하여 테스트 환경을 완전히 통제해야한다.


    
# 테스트 환경의 독립성을 보장하자

---

## 테스트 실패와 관련된 문제 부분 
* 대상 테스트 :  `OrderServiceTest.createOrderWithNoStock`
* given / when / then 중 잘못된 설계의 문제는 거의 항상 given에서 발생
* 문제의 원인 : 테스트 간 결합, 즉 아래부분을 무심코 끌어다 쓰는 경우 테스트 간 결합 가능성이 생긴다.
  * 다른 테스트에서 사용한 API
  * 다른 도메인의 행위
  * 상태 변경 메서드
* 문제 예시 
  * `@DisplayName("재고가 부족한 상품으로 주문을 생성하려는 경우 예외가 발생한다.")`
  * 즉 위 테스트 주제는 "재고가 부족하면 주문 생성이 실패" 하는데에 있다.
  * 하지만 given절에서 직접적으로 재고 차감 로직을 호출 
    * `stock1.deductQuantity(1);` 👉 문제의 핵심 포인트
    * 해당 테스트는 재고 차감(`deductQuantity`) 로직을 테스트 하려는게 아닌 주문 생성 로직(`createOrder`)에 있다 <br>
      👉 주제와 맞지 않는 행위를 given에 끌어옴
  * 위 문제가 안좋은 이유는 : 테스트 환경이 행위에 의존함<br>
    재고를 “만들기 위해” 재고 차감이라는 행위 API를 사용 👉 이건 테스트 환경 구성에: 비즈니스 로직이 끼어든 상태

## 테스트의 기본 원칙
  * 테스트 환경을 독립성을 보장하여 "왜"실패했는지를 명확하게 만들어야 한다.
  * 각 테스트는 서로에게 영향을 주지 않아야 하며, 실패했을 때 그 원인이 오직 “해당 테스트의 목적” 때문이어야 한다.
  * 테스트 환경은 행위로 만들지 말고, 상태로 만들어라.
  * 즉, deduct / create와 같은 행위메서드를 사용하는 것 보단
  * 생성자 / 빌더 / 순수 팩토리 메서드를 사용하는 것이 더 테스트 의도를 드러내는데 좋다. <br>
    ※ 프로덕션 코드에서 팩토리 메서드는 의도를 담고있다. 그러므로 테스트 코드에서는 순수 생성자 / 빌더가 더 적합한 경우가 많음



# 테스트 간 독립성을 보장하자

---
## 테스트 실패와 관련된 문제 부분
* 대상 테스트 : `StockTest`의 주석 부분의 `final stock` 변수
  * 여러 테스트가 하나의 공유 자원을 사용함 👉 테스트 실행 순서에 따라 결과가 바뀌는 구조
  
## 테스트의 기본 원칙 👉 테스트 간 독립성 보장
* 각 테스트는 서로 영향을 주면 안 된다
* 실행 순서에 따라 성공/실패가 달라지면 안 된다
* 어떤 테스트든 단독 실행 / 전체 실행 모두 동일한 결과를 내야 한다

## 만약 테스트 간 순서를 제어하고 싶다면?
* Dynamic Test
* Parameterized Test
