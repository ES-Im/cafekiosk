# [Practical Testing: 실용적인 테스트 가이드](https://inf.run/iEtUM)

# 단위 테스트

## 수동 테스트 VS. 자동화된 테스트

1. 요구사항
   * 주문 목록에 음료 추가 / 삭제 기능
   * 주문 목록 전체 지우기
   * 주문 목록 총 금액 계산하기
   * 주문 생성하기


2. 수동테스트
    * 문제점 : 최종 단계에서 사람이 개입 & 맞는 상황과 틀린 상황에 대한 검증식이 없음
``` 
@Test
void add() {
CafeKiosk cafeKiosk = new CafeKiosk();
cafeKiosk.add(new Americano());

    System.out.println("담긴 음료 수 : " + cafeKiosk.getBeverages().size() );
    System.out.println("담긴 음료 : " + cafeKiosk.getBeverages().get(0).getName());
}
```

## [Junit5](https://junit.org/junit5) 로 테스트 하기

1. 단위 테스트를 위한 테스트 프레임워크 
   * **작은** 코드 단위를 **독립적**으로 검증하는 테스트
     * 작은 단위 : 클래스/메소드 단위
     * 독립적 : 외부 상황에 의존하지 않는 클래스나 메서드만 검증
   * 검증속도가 빠르고, 안정적이다.
    
2. XUnit - Kent Beck에서 발전
3. [AssertJ](https://joel-costigliola.github.io/assertj/index.html) 라이브러리 
   * 테스트 코드 작성을 원활하게 돕는 테스트 라이브러리
   * 풍부한 API, 메서드 체이닝 지원

4. 자동테스트 : 사람이 개입하지 않더라도, 프로덕션 코드가 정상 동작하고 있는지를 수시로 체크해 볼 수 있다.
```
    @Test
    void getName() {
        Americano americano = new Americano();
        assertEquals(americano.getName(), "아메리카노"); //  junit의 assert문
        assertThat(americano.getName()).isEqualTo("아메리카노"); // assertj의 assertThat문 → 메서드 체이닝으로 더 풍부한 검증 가능
    }
```

## 테스트 케이스 세분화 하기 
1. "암묵적이거나 아직 드러나지 않은 요구사항이 있는가?"(예외 케이스) 를 계속해서 질문해야함
   * `해피 케이스` : 주문 목록에 음료 추가
   * `예외 케이스`: 화면에서 아메리카노 0잔을 입력했을때 테스트케이스를 어떻게 할 것인가
2. 경계값 테스트 : 범위(이상, 이하, 초과, 미만), 구간, 날짜 등
   * 경계값이 있는 테스트가 있을 경우 경계값 전후 값을 테스트하는게 효용성 있다 
   * 예를 들어 경계가 3일 때 `해피케이스 3`에 대한 검증 `예외케이스 2`에 대한 검증을 하면 된다.
      
`해피케이스`
```
    @Test
    void addSeveralBeverage() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();

        cafeKiosk.add(americano, 3);

        System.out.println("담긴 음료 수 : " + cafeKiosk.getBeverages().size() );
        System.out.println("담긴 음료 : " + cafeKiosk.getBeverages().get(0).getName());
    }
```
`예외 케이스`
```
    @Test
    void addZeroBeverage() {
        CafeKiosk cafeKiosk = new CafeKiosk();
        Americano americano = new Americano();

        Assertions.assertThatThrownBy(
                () -> cafeKiosk.add(americano, 0))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessage("1잔 이상 주문 가능");
    }
```

## 테스트하기 어려운 영역을 분리하기 
1. 예시 요구사항 : 가게 운영 시간 외에는 주문을 생성할 수 없다.
   * 현재 시간이 영업시간 전이라면 주문이 안된다 → 메서드의 매개변수로 설정하지 않으면 테스트가 어려움`untestable`
   * 이에 `LocalDateTime`을 매개값으로 빼면(외부로 값을 분리하면) `testable` 영역이 된다.
2. 테스트 코드 상에서 원하는 값을 넣어줄 수 있도록 설계를 해야한다. 
3. 테스트 어려운 영역을 구분을 해서 외부로 분리할수록 테스트 가능한 코드는 많아진다.
4. 테스트하기 어려운 영역이란? _외부세계와 영향을 주고 받는 값_
   * 관측할 때마다 다른 값에 의존하는 코드 : 현재 날짜/시간, 랜덤 값, 전역 변수/함수, 사용자 입력 등
   * 외부 세게에 영향을 주는 코드 : 표준 출력, 메시지 발송, DB에 기록하기 등
5. 테스트하기 쉬운 영역? _외부 세계와 단절된 함수(순수함수)_
   * 같은 입력에는 항상 같은 결과
   * 외부 세상과 단절된 형태
   * 테스트하기 쉬운 코드
6. 결론 : 테스트 하기 어려운 기능이 있다면, 외부세계와 영향을 주고 받는 값을 외부로 값을 분리하는 것을 고려할 것


# TDD : Test Driven Development

## TDD란?
1. 프로덕션 코드보다 테스트 코드를 먼저 작성하여 테스트가 구현 과정을 주도하도록 하는 방법론
2. Red Green Refactoring 
   * RED : 실패하는 테스트 작성
   * GREEN : 테스트 통과 최소한의 코딩, 이 단계에서는 초록불을 보기위해 막 설계해도된다.
   * REFACTOR : 구현 코드 개선, 테스트 통과 유지, 이 단계에서 초록불을 유지하면서 리팩토링을 한다.
3. 익스트림 프로그래밍(XP) "테스트 우선" 문화를 구체적인 개발 절차로 만든 것이 TDD

## 피드백(TDD의 핵심가치)와 도입전후 비교
1. 프로덕션 코드에 대해서 자주 그리고 빠르게 피드백을 받을 수 있다.
2. 선 기능 구현, 후 테스트 작성의 문제점
    * 테스트 자체의 누락 가능성
    * 특정 테스트 케이스만 검증할 가능성 (해피케이스만)
    * 잘못된 구현을 다소 늦게 발견할 가능성
3. 선 테스트 작성, 후 기능 구현
    * 복잡도가 낮음(유연하며 유지보수가 쉬운), 테스트가 가능한 코드로 구현할 수 있게 한다. → 테스트가 하기 어려운 기능을 미리 외부로 값을 분리해 테스트 구조에 대한 시간 절약
    * 쉽게 발견하기 어려운 엣지(Edge) 케이스를 놓치지 않게 해준다.
    * 구현에 대한 빠른 피드백을 받을 수 있다.
    * 과감한 리팩토링이 가능해진다.
## 관점의 변화
   - 즉, **테스트는 구현부 검증을 위한 보조 수단** 이 아니라<br> 
     **테스트와 상호 작용하며 발전하는 구현부** 로 본다는 관점의 변화를 준다<br>
     = **클라이언트 관점에서의 피드백을 주는 Test Driven**

# 테스트는 []다.
## 테스트는 [문서]다.
- 문서?
    * 프로덕션 기능을 설명하는 테스트 코드 문서
    * 다양한 테스트 케이스를 통해 프로덕션 코드를 이해하는 시각과 관점을 보완
    * 어느 한 사람이 과거에 경험했던 고민의 결과물을 팀 차원으로 승격시켜서, 모두의 자산으로 공유 가능

## DisplayName을 섬세하게
- 명사의 나열보다는 문장으로 섬세하게 작성
- 테스트 행위에 대한 결과까지 기술
- 도메인 용어를 사용하여 한층 추상화된 내용을 담기 <br>
  (용어사전 지키고, 메서드 자체의 관점보다 도메인 정책으로 관점으로)
- 테스트의 현상을 중점으로 기술하지 말 것
  * "음료 1개 추가 테스트" - x
  * "음료를 1개 추가하면 주문 목록에 담긴다" - o
  * "특정 시간 이전에 주문을 생성하면 실패한다" - x
  * "영업 시작 시간 이전에는 주문을 생성할 수 없다" - o

## BDD 스타일로 작성하기
- TDD에서 파생된 개발 방법
- 함수 단위의 테스트에 집중하기 보다, 시나리오에 기반한 테스트케이스(TC) 자체에 집중하여 테스트<br>
  즉, 성공/실패 결과를 나타내는게 아니라 어떤 '행동'이 '어떤 결과'를 낳는지를 표현해야한다
- 개발자가 아닌 사람이 봐도 이해할 수 있을 정도의 추상화 수준(레벨)을 권장
- `Given` `When` `Then`  →  DisplayName에 명확하게 작성할 수 있다.
  * 어떤 환경`Given`에서, 어떤 행동을 진행했을 때`When`, 어떤 상태 변화가 일어난다`Then`
    * `Given` : 시나리오 진행에 필요한 모든 준비 과정(객체, 값, 상태 등)
    * `When` : 시나리오 행동 진행
    * `Then` : 시나리오 진행에 대한 결과 명시, 검증
```
    @Test
    @DisplayName("주문 목록에 담긴 상품들의 총 금액을 계산할 수 있다.")
    void calculateTotalPrice() {
        // given
        Americano americano = new Americano();
        CafeKiosk cafeKiosk = new CafeKiosk();
        Latte latte = new Latte();

        cafeKiosk.add(americano, 1);
        cafeKiosk.add(latte, 1);

        // when
        int totalPrice = cafeKiosk.calculateTotalPrice();

        // then
        assertThat(totalPrice).isEqualTo(8500);
    }
```
- (참고) `spock` : Groovy 언어를 기반으로 한 BDD(행동 주도 개발) 스타일 테스트 프레임워크로 given/when/then이 기본 틀

# Spring & JPA 기반 테스트
## 레이어트 아키텍처(Layered Architecture)와 테스트
### 통합테스트
  * 여러 모듈이 협력하는 기능을 통합적으로 검증하는 테스트
  * 일반적으로 단위테스트만으로는 기능 전체의 신뢰성을 보장할 수 없다
  * 풍부한 단위 테스트 & 큰 기능 단위를 검증하는 통합테스트

### 요구사항 정리
  * 키오스크 주문을 위한 상품 후보 리스트 조회하기
  * 상품의 판매 상태 : 판매중, 판매보류, 판매중지
    <br> → 판매중, 판매보류인 상태의 상품을 화면에 보여준다
  * id, 상품 번호, 상품 타입, 판매 상태, 상품 이름, 가격

## 테스트 annotation
  * `@SpringBootTest` : 애플리케이션 전체 컨텍스트를 로딩하는 통합 테스트용 설정
  * `@DataJpaTest` : JPA 관련 Bean만 로딩하는 Repository 전용 Slice 테스트, 기본적으로 트랜잭션 적용 + 롤백

## Persistence test
  * DB에 액세스하는 로직만 갖고 있기 때문에 단위 테스트 성격을 가지고 있음
```aiignore
@ActiveProfiles("test")     ▶ Application.yml 파일에 설정한 profiles을 선택
@DataJpaTest                ▶ JPA 관련 Bean만 로딩하는 Repository 전용 테스트 @SpringBootTest 로 해도 결과는 변함이 없음
class ProductRepositoryTest {

    @Autowired ProductRepository productRepository;

    @Test
    void findAllBySellingStatusIn() {
        Product product1 = Product.builder()
        ...(생략)...

        List<Product> products = productRepository.findAllBySellingTypeIn(List.of(SELLING, HOLD));

        assertThat(products).hasSize(2)
                .extracting("productNumber", "name", "sellingType")     ▶ 컬렉션 요소에서 지정한 필드만 추출하고 Tuple 형태로 변환한다.
                .containsExactly(                                       ▶ 내용과 순서가 정확히 일치하는지 검증
                        tuple("001", "아메리카노", SELLING),             ▶ extracting으로 나온 튜플과 일치한지 비교를 위한 비교용 Tuple 객체 생성
                        tuple("002", "카페라떼", HOLD)                    
                );     
    }
} ※ containsExactly 순서까지 일치, containsExactlyInAnyOrder 순서 상관없이
```

## Business Layer test
### Business Layer
  * 비즈니스 로직을 구현하는 역할
  * Persistence layer와의 상호작용(Data를 읽고 쓰기)를 통해 비즈니스로직 전개
  * 트랜잭션이 보장되어야 함
### 요구사항 정리
  * 상품 번호 리스트를 받아 주문 생성
  * 주문은 주문 상태, 주문 등록 시간을 가짐
  * 주문의 총 금액을 계산할 수 있어야 한다.
### JUnit 메서드

  * `isEqualByComparingTo` : comparable 기준 compareTo로 같은지 검증하기 위해 사용
```aiignore
assertThat(order.getOrderStatus())
    .isEqualByComparingTo(OrderStatus.INIT);
```
### OrderServiceTest
- @SpringBootTest에서 tearDown를 사용한 이유
  * DB 클렌징을 하지 않으면 productNumber가 duplicate 되었다고 테스트 실패<br>
   ->  각 테스트가 createProduct가 누적되어 문제가 된상황. 즉 transaction 상 롤백이 안됌<br>
   -> Transactional 처리를 수동으로 맞춰 주어야 한다.
  
  * 즉 @SpringBootTest에는 @Transactional가 미포함되어있다!
  * ( @DataJpaTest는 @Transactional이 내포되어있음. 즉 클렌징 작업 필요없음 )
- 그럼 tearDown말구 @SpringBootTest + @Transactional 콜라보해서 쓰면 되는거 아닌가??? → 거기에도 문제가 있음

```aiignore

@ActiveProfiles("test")
@SpringBootTest
class OrderServiceTest {

    // ...(생략)...

    @AfterEach
    void tearDown() {
        orderProductRepository.deleteAllInBatch();
        productRepository.deleteAllInBatch();
        orderRepository.deleteAllInBatch();
    }

    @Test
    void createOrder() {
        // given
        Product product1 = createProduct(HANDMADE, "001", 1000);
        // 생략
        productRepository.saveAll(List.of(product1, product2, product3));

        // ...(생략)...
    }

    @Test
    void createOrderWithDuplicateProductNumbers() {
        // given
        Product product1 = createProduct(HANDMADE, "001", 1000);
        // 생략
        productRepository.saveAll(List.of(product1, product2, product3));

        // ...(생략)...
    }
```
### HTTP 관련 테스트는 어케함? 
  * 도메인별로 http 파일을 만들어서 하면 된다. → 최상위 폴더에 HTTP 디렉토리 생성
  * 양식은 아래와 같음
```aiignore
### 주문 신규 생성
POST localhost:8080/api/v1/orders/new
Content-Type: application/json

{
  "productNumbers": [
    "001",
    "002"
  ]
}
```
### 요구사항 정리 
  * 주문 생성 시 재고 확인 및 개수 참감 후 생성하기 
  * 재고는 상품번호를 가진다.
  * 재고와 관련 있는 상품 타입은 병 음료, 베이커리이다.

### 테스트 및 설계에 대한 원칙
  * 간단한 거라도 미래시점에 용어가 달라지는 등 가능성이 있기 때문에 테스트를 만들어 두어야 한다.
```aiignore
    @Test
    @DisplayName("재고의 수량이 제공된 수량보다 작은지 확인한다.")
    void isQuantityLessThan() {
        // given
        Stock stock = Stock.create("001", 1);
        int quantity = 2;
        // when
        boolean result = stock.isQuantityLessThan(quantity);

        // then
        assertThat(result).isTrue();
    }
```
  * 같은 검증이라도 “어디서 왜 하느냐”에 따라 의미가 달라지며, 이는 중복이 아니라 책임 분리다.
```aiignore
1) Service Layer : OrderService
 - 서비스 레이어에서의 체크는 “이 작업을 지금 시도해도 되는가?”를 묻는 단계

if(stock.isQuantityLessThan(quantity)) {
    throw new IllegalArgumentException("재고가 부족한 상품이 있습니다.");
}
            
2) Domain Layer : Stock    
 - 도메인 레이어에서의 체크는 "외부를 절대 믿지 않는다"는 전제
        
if(isQuantityLessThan(quantity)) {
    throw new IllegalArgumentException("차감할 재고 수량이 없습니다");
}

즉, 검증 로직은 역할에 따라 중복될 수 있다
도메인레이어에서 데이터/상태를 바꾸는 로직은 항상 자기 자신이 안전을 보장해야 한다
서비스 레이어는 사용자 경험과 흐름 제어에 집중한다
```

## @Transactional

---
### @Transactional의 역할 - 1.변경 감지(Dirty Checking)
  * 더티 체킹이 동작하는 조건 
    - 엔티티가 `영속 상태`일 것 ( ==  Detached(준영속) 상태에서는 안 된다)
    - `transaction` 안에서 변경될 것
  * 더티 체킹 내부 흐름
    - 엔티티 조회 : JPA가 최초 상태 스냅샷을 저장(JPA는 엔티티를 조회하면 1차 캐시에 저장하고 최초 상태 스냅샷을 같이 보관)
    - 자바 코드 값 변경 (아직 DB변경 x)
    - 트랜잭션 커밋 시점 : 스냅샷과 현재 값 비교
    - 값이 다르면 `UPDATE` SQL 쿼리 생성 및 실행<br>
    → 즉, save()쿼리를 실행하지 않아도 JPA 프레임 워크가 변경 책임을 대신 져주는 것
    
  * 즉, 더티체킹을 활용하지 않으려면 비즈니스로직에서 save를 통해 update를 해줘야 한다.
```aiignore
public OrderResponse createOrder(OrderCreateRequest request, LocalDateTime registeredDateTime) {
    // ...(생략)...
    Order savedOrder = orderRepository.save(order);
    return OrderResponse.of(savedOrder);
}
```
---
### @Transaction의 역할 - 2. 자동롤백
 * 테스트 메서드에 @Transactional 사용 시 테스트 종료 후 자동 롤백 DB 상태가 깨끗하게 유지됨
 * 즉, 매번 데이터 삭제 코드 작성이 불필요해서 테스트 코드가 단순해진다.
---
### 테스트 트랜잭션 주의점
   * 테스트에서 @Transactional 덕분에 더티 체크가 정상 동작하고 UPDATE 쿼리도 정상확인이 된다
   * 하지만 실제 서비스 코드에서 트랜잭션이 설정되지 않으면 배포 후에야 문제 발견 가능
   * 그러므로 테스트에서는 자동 롤백 방식 대신 수동 삭제(tearDown) 방식을 유지하는 것도 해결방안이며, 이는
     * 트랜잭션에 의존치 않은 테스트를 작성하여 숨겨진 문제를 조기에 발견할 수 있다.
```aiignore
@AfterEach
void tearDown() {
    orderProductRepository.deleteAllInBatch();
    productRepository.deleteAllInBatch();
    orderRepository.deleteAllInBatch();
    stockRepository.deleteAllInBatch();
}
```
---
### @Transactional(readOnly = true)
#### 기본 개념
    - @Transactional(readOnly = true)는 읽기 전용 트랜잭션(Read Transaction) 임을 명시적으로 선언하는 옵션이다.
    - ❌ CUD(Create / Update / Delete) 불가
    - ✅ Read 전용 트랜잭션 : 트랜잭션 범위는 유지되지만 변경을 허용하지 않음
    
#### JPA 관점에서의 동작 방식 (성능 포인트)
    - readOnly = true가 설정되면 JPA(Hibernate)는 내부 동작을 최적화한다.
    - ❌ 스냅샷(Snapshot) 저장 안 함
    - ❌ Dirty Checking(변경 감지) 비활성화
    - ❌ flush 시점의 UPDATE SQL 생성 안 함
    - ✅ 메모리 사용량 감소
    - ✅ 조회 성능 향상
    
#### CQRS 관점에서의 의미
    - CQRS(Command Query Responsibility Segregation)는 쓰기(Command)와 읽기(Query)의 책임을 분리하는 아키텍처 패턴이다.
    - 핵심 이유
        1. 대부분의 시스템 부하는 Read에서 발생
        2. Read 부하 때문에 Write(Command)가 지연되면 안 됨
        3. 따라서: Read는 Read에 최적화 Write는 Write에 집중
#### 서비스 레벨 분리 전략
    ① 쿼리(Query) 서비스와 커맨드(Command) 서비스 분리 

    ② 클래스에 readOnly=true를 걸고
    👉 CUD 메서드에만 명시적으로 @Transactional을 선언하면
    👉 CUD 누락 사고를 방지할 수 있다.
         ↓
        @Transactional(readOnly = true)
        @Service
        public class ProductService {
        
            public ProductResponse getProduct(Long id) {
                // 조회 로직
            }
        
            @Transactional // readOnly = false
            public ProductResponse createProduct(ProductCreateRequest request) {
                // 생성 로직
            }
        }

#### DB 엔드포인트 분리 전략 
    Aurora / MySQL Replication 구조에서는 보통:
     - Master DB :Write(CUD) 전용
     - Replica(Slave) DB : Read 전용
    이때 readOnly 값으로 DB 라우팅 분리가 가능하다.
#### DB 엔드포인트 분리 방법
    ① Amazon Aurora Cluster Mode
        하나의 엔드포인트 사용
        Aurora가 readOnly 여부를 보고 자동 라우팅
    ② Spring에서 명시적 분리
        DataSource를 Read / Write로 분리
        라우팅 DataSource 사용

---
### @Transactional이 없는데도 insert와 delete 쿼리가 자동 실행되는 이유?
  * CRUDRepository 의 구현체를 보면 `save`에 @Transactional이 설정이 되어있다<br> 그래서 `insert` 쿼리와 delete 쿼리는 자동 감지가 된다.



## 동시성 이슈

---
### 방법 1 : 유니크 인덱스 걸고 시스템에서 알아서 하는 재시도 로직을 넣기 
  * 동시성 이슈가 발생할 가능성은 있지만, 그 빈도가 높지 않을 경우 사용
  * 이 경우 무한루프 방지를 위해 최대 횟수 (2 ~ 3회)를 지정해야한다.
```aiignore
try {
    save();
} catch (DuplicateKeyException e) {
    retry();
}
```
### 방법 2 : 필드에 UUID 값을 넣도록 하기
  * 동시접속자가 너무 많은 경우 이용
```aiignore
String id = UUID.randomUUID().toString();
```
<br>

## Presentation Layer

---
### 프레젠테이션 레이어 역할
* 외부 세계의 요청을 가장 먼저 받는 계층
* 파라미터에 대한 최소한의 검증을 수행
### 테스트 방법 - 설명
* Business Layer와 Persistence Layer같은 경운 통으로 같이 테스트 했지만,
* Presentation Layer 같은 경운 하위레이어들을 `Mocking` 처리를 하고 단위테스트 느낌으로 테스트
  * Mocking 처리 : mockito의 도움을 받아 Mock 객체를 생성을 하고, 컨테이너에 Mockito로 만든 Mock 객체를 MockBean에 넣는다. 
  * 즉, 아래 코드는 Spring Context에 등록된 ProductService Bean을 제거하고 <br>
    Mockito가 만든 Mock ProductService를 대신 등록한다
```aiignore
    @MockitoBean
    private ProductService productService;
    
    즉, 
    ProductController에서 private final ProductService productService; 
    ↑ 이 빈 주입을 Mockito가 만들고 Spring이 등록을 하여 @WebMvcTest가 가능하게 끔 한다.
```
* MvcTest 중 configuration bean 생성 오류가 뜰경우 해결 방법<br> 
  ```오류 예시 : Error creating bean with name 'jpaAuditingHandler': Cannot resolve reference to bean 'jpaMappingContext' while setting constructor argument```
  * BaseEntity를 위한 Jpa의 Auditing기능을 사용하기 위해 @EnableJpaAuditing 을 빈으로 등록했지만, 컨트롤러 전용 테스트라서 빈생성이 안됨 <br> → 설정정보를 분리하면 된다.
    ```
    @Configuration
    @EnableJpaAuditing
    public class JpaAuditionConfig {
    }
    ```
### Mocking 이용
* Mock : 가짜, 대역
* 쓰는 이유 : 의존관계 -> 테스트를 방해 -> 의존관계를 가짜로 잘 동작하는 걸 가정하고 테스트 하고 싶다.
* MockMvc 프레임 워크 : Mock(가짜) 객체를 사용해 스프링 MVC 동작을 재현할 수 있는 테스트 프레임 워크.
### ObjectMapper
#### Post 방식의 직렬화와 역직렬화 - ObjectMapper 주입을 위한 배경 지식
* POST 요청은 객체를 그대로 보내는 게 아니라, 직렬화된 데이터(JSON 등)를 보내고 서버에서 다시 역직렬화해서 객체로 만든다
* 직렬화 : 객체(데이터 구조)를 전송 가능한 형태(문자열, 바이트)로 변환하는 것<br> 네트워크는 객체를 그대로 보낼 수 없고 👉 문자열 또는 바이트 형태만 전송 가능하기 때문
    * 대표적 직렬화 포맷 : JSON, XML, Binary
* 역직렬화 : 전송된 문자열/바이트 데이터를 다시 객체로 복원하는 과정. Spring에서 역직렬화를 자동으로 처리해 준다.
```
 [클라이언트]
   객체
    ↓ << 직렬화 >>
  JSON 문자열
    ↓ POST Body
 ==================== 네트워크 ====================
    ↓
 [서버]
  JSON 문자열
    ↓ << 역직렬화 >>
   객체
```
#### 그래서 ObjectMapper는 왜 쓰는데?
* HTTP body에는 직렬화된 값(byte배열 또는 String 형태)이 들어가야함 <br> -> ObjectMapper는 JSON ↔ Object 간의 직렬화 ↔ 역직렬화를 도와준다.
### 테스트 방법 - 예시
```
@WebMvcTest(controllers = ProductController.class)      // 컨트롤러 단위 테스트 
class ProductControllerTest {
    @Autowired private MockMvc mockMvc;                 // 실제 서버 없이 HTTP 요청/응답을 시뮬레이션하는 객체 (가짜 HTTP 요청을 보내는 테스트용 MVC 객체)
    @MockitoBean private ProductService productService; // 모키토가 대신 ProductService 가짜 빈(Mock)을 등록
    @Autowired ObjectMapper objectMapper;               // Post방식 직렬화 <> 역질력화

    @Test
    void createProduct() throws Exception {
        // given - 객체 생성
        ProductCreateRequest request = ProductCreateRequest.builder()......

        // when & then  - Http Body에 데이터 JSON 형태로 직렬화
        mockMvc.perform(MockMvcRequestBuilders.post("/api/v1/products/new")     // 앤드포인트
                .content(objectMapper.writeValueAsBytes(request))               // 직렬화
                .contentType(MediaType.APPLICATION_JSON)                        // JSON
        )
                .andDo(MockMvcResultHandlers.print())                           // 목에대한 자세한 로그를 볼 수 있다.
                .andExpect(MockMvcResultMatchers.status().isOk());              // 200 code 기대

    }
}
```
### 공통적으로 사용할 수 있는 응답 포맷 만들기
- [POST 요청]
  1. `ProductCreateRequest`에서 Validation 설정 및 바인딩 오류 메시지 설정
  2. `ApiResponse` : 제너릭을 이용해서 ApiResponse 포맷팅 클래스을 설정
      - Generic을 이용함으로 컨트롤러에서 반환값을 공통 형식으로 묶어버릴 수 있음
      - 컨트롤러에서 `ApiResponse<ProductResponse> createProduct(....) {}`와 같이 사용
  3. `ApiControllerAdvice` : Valid 위반 시 예외도 ApiResponse에 담아지도록 ControllerAdvice 만듦
      - 특히 해당 클래스에서 이용한 `BindException`는 Spring Validation 위반 예외이며
      - `getBindingResult().getAllErrors().get(0).getDefaultMessage()`에서 가져온 메시지는 Validation에서 설정한 오류 메시지 이다.

### GET요청 테스트하기 
- 파라미터 없는 경우
- 파라미터 있는 경우 



#### 

####  


## Spring Validation

---
### 사용방법 
  * DTO에 제약 annotation을 붙이고
  * Controller에서 받는 매개타입 앞에 @Valid 붙이기
### constraint 종류
   - `@NotNull` : null만 아니면 된다 / "", "   " 둘 다 통과 o → 그러므로 Enum 타입은 @NotNull로 써도 충분
   - `@NotBlank` : 무조건 문자가 있어야함 / "", "   " 통과 x
   - `@NotEmpty` : 값만 있으면 된다 / "   "은 통과 o ""는 통과 x
   - `@Positive` : 양수
### Validation 책임분리에서 고민해봐야할 것
  * 도메인 규칙 :  <br>
    → 이를 DTO에서 `@Max` 검사하는게 맞나?
  * 문자열 Validation에는 크게 두가지 수준이 존재한다
    1) 형식적·기초적 검증 : Notnull, isEmpty, NotBlank 등
    2) 도메인 의미를 가진 검증 : "상품이름으로서 유효한가?"
  * "상품이름은 String 20자를 넘어선 안된다"는 규칙은 단순한 문자열 길이 체크처럼 보이지만, 사실상 도메인 정책일 가능성이 크다<br>
    이에 해당 정책을 controller에서 검증해버리면 도메인 규칙이 컨트롤러에서 고정되고 다른 레이어에서 같은 검증을 중복 구현할 가능성이 크다.
  * 그러므로
    - 이 규칙이 없다면 이 도메인은 깨지는가? 를 고민하고 깨지면 도메인, 깨지지 않는다면 컨트롤러에서 검증하면 된다.
  * 여기서 고민 : "상품 이름은 20자를 초과할 수 없습니다"라는 클라이언트에 도메인 규칙을 설명하는 메시지는 어떻게 보내나?
    - 서비스 / 도메인 계층에서 해당 검증을 처리한다면 예외를 던지면 된다.
    - 즉, 서비스/도메인 + 예외 + ControllerAdvice 으로 메시지를 던져버리면 된다.

## DTO분리를 통한 컨트롤러와 서비스 레이어의 의존관계 

---
### Request DTO 
  * request는 일차적으로 Bean Validation을 하므로 Controller에서 선언한다.
  * 그러므로 이를 서비스레이어에서 까지 쓰이면 하위레이어가 상위레이어를 아는 관계가 되어버려 의존관계가 깨진다. 
  * 그러므로 service용 request를 따로 만든다.
    - OrderCreateRequest -(toServiceRequest)-> OrderCreateServiceRequest 
    - 클래스 참고 : OrderController - OrderCreateServiceRequest - OrderService
### Response DTO
  * 보통 Service 레이어에서 정의하고 이를 컨트롤러에서 받아 사용하기 때문에 자연스럽게 계층이 분리되어있다. 
  * 그러므로 신경 안써도 된다.
#### 그러므로 의존성 및 책임분리, 향후 유지보수 측면에서 서비스용 Request DTO, 컨트롤러용 Request DTO를 만들어두는 것이 좋다

## 레이어드아키텍쳐 → 헥사고날아키텍쳐

---
  * 레이어드아키텍쳐 : 도메인이 JPA와 실질적으로 강결합되어있는 형태 
  * 헥사고날아키텍쳐 : 포트를 통해서 외부와 통신 -> 도메인 모델은 외부의 것을 알지 못한다
    * 데이터 액세스를 위한 repository interface를 따로 두고 이를 구현하는 어떤 JPA repository를 따로 들어서 런타임 시점에 주입을 해준다면
    * 도메인 객체는 JPA라는 구현 기술을 몰라도 가능하다.
  * 시스템이 커지고 모듈이 많아지면 헥사고날 아키텍쳐가 좋은 선택이다.

## QueryDSL 

---
```
@RequiredArgsConstructor
@Repository
public class ProductApiRepository {

    private final JPAQueryFactory queryFactory;
    
    public List<Product> findProductsBySellingStatusIn(List<ProductSellingStatus> sellingStatuses) {
        return queryFactory
                .selectFrom(QProduct.product)
                .where(
                        Qproduct.product.sellingStatus.in(sellingStatuses)
                )
                .fetch();
    }
}
```
  * JPA, SQL, MongoDB 등을 타입 안전한 자바 코드로 쿼리할 수 있게 해주는 라이브러리
  * QueryDSL의 강점
    * 컴파일 단계에서 오류 검출
    * IDE 자동 완성 지원
    * 리팩토링 안전


## Mock

---
### Mock 
  * 실체 객체를 대신 하는 가짜 객체이며, 실제로직이 아닌, 내가 정해준 동작만 수행한다.
### 사용방법
1. `@WebMvcTest(controllers = ProductController.class)`<br> : 컨트롤러 빈들만 올릴 수 있는 가벼운 케스트 어노테이션<br> : 테스트 하고자 하는 클래스를 명시해준다.
2. import org.springframework.boot.test.mock.mockito.MockBean; 빈 주입 필요
3. [Mockito 라이브러리](site.mockito.org) 사용 : spring-boot-starter-test 의존성에 포함됨 

```aiignore
@WebMvcTest(controllers = ProductController.class)
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean;
    private ProductService productService;

```









